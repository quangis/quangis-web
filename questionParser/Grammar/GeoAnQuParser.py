# Generated from GeoAnQu.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3T")
        buf.write("\u02b2\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\3\2\3\2\3\2\3\2\5\2U\n\2\3\2\3\2\3\2\5")
        buf.write("\2Z\n\2\3\2\5\2]\n\2\5\2_\n\2\3\2\3\2\5\2c\n\2\3\2\5\2")
        buf.write("f\n\2\3\2\5\2i\n\2\5\2k\n\2\3\2\3\2\3\2\5\2p\n\2\7\2r")
        buf.write("\n\2\f\2\16\2u\13\2\3\2\5\2x\n\2\3\2\3\2\3\2\5\2}\n\2")
        buf.write("\5\2\177\n\2\3\2\5\2\u0082\n\2\3\2\5\2\u0085\n\2\3\2\3")
        buf.write("\2\5\2\u0089\n\2\3\2\5\2\u008c\n\2\3\2\5\2\u008f\n\2\3")
        buf.write("\2\3\2\5\2\u0093\n\2\6\2\u0095\n\2\r\2\16\2\u0096\7\2")
        buf.write("\u0099\n\2\f\2\16\2\u009c\13\2\3\2\5\2\u009f\n\2\3\2\3")
        buf.write("\2\5\2\u00a3\n\2\3\2\5\2\u00a6\n\2\5\2\u00a8\n\2\3\3\3")
        buf.write("\3\3\4\3\4\3\4\3\4\3\4\5\4\u00b1\n\4\3\4\5\4\u00b4\n\4")
        buf.write("\3\4\3\4\5\4\u00b8\n\4\6\4\u00ba\n\4\r\4\16\4\u00bb\3")
        buf.write("\4\3\4\5\4\u00c0\n\4\3\4\5\4\u00c3\n\4\3\4\5\4\u00c6\n")
        buf.write("\4\3\4\3\4\5\4\u00ca\n\4\7\4\u00cc\n\4\f\4\16\4\u00cf")
        buf.write("\13\4\3\4\5\4\u00d2\n\4\3\4\5\4\u00d5\n\4\3\4\3\4\3\4")
        buf.write("\5\4\u00da\n\4\3\4\5\4\u00dd\n\4\3\4\7\4\u00e0\n\4\f\4")
        buf.write("\16\4\u00e3\13\4\3\4\5\4\u00e6\n\4\3\4\5\4\u00e9\n\4\3")
        buf.write("\4\7\4\u00ec\n\4\f\4\16\4\u00ef\13\4\3\4\5\4\u00f2\n\4")
        buf.write("\3\4\7\4\u00f5\n\4\f\4\16\4\u00f8\13\4\3\4\3\4\3\4\3\4")
        buf.write("\5\4\u00fe\n\4\3\5\3\5\3\5\3\6\3\6\5\6\u0105\n\6\3\6\5")
        buf.write("\6\u0108\n\6\3\6\3\6\5\6\u010c\n\6\3\6\3\6\5\6\u0110\n")
        buf.write("\6\6\6\u0112\n\6\r\6\16\6\u0113\3\6\3\6\5\6\u0118\n\6")
        buf.write("\5\6\u011a\n\6\3\6\5\6\u011d\n\6\3\7\3\7\3\b\3\b\5\b\u0123")
        buf.write("\n\b\3\b\3\b\3\b\5\b\u0128\n\b\3\b\3\b\5\b\u012c\n\b\3")
        buf.write("\b\5\b\u012f\n\b\3\t\3\t\3\t\5\t\u0134\n\t\3\t\3\t\3\n")
        buf.write("\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\5\n\u0144")
        buf.write("\n\n\5\n\u0146\n\n\3\n\5\n\u0149\n\n\3\n\5\n\u014c\n\n")
        buf.write("\3\n\3\n\5\n\u0150\n\n\3\n\5\n\u0153\n\n\3\n\3\n\5\n\u0157")
        buf.write("\n\n\3\n\5\n\u015a\n\n\3\n\3\n\3\n\3\n\6\n\u0160\n\n\r")
        buf.write("\n\16\n\u0161\3\n\5\n\u0165\n\n\3\n\5\n\u0168\n\n\3\n")
        buf.write("\3\n\5\n\u016c\n\n\3\n\3\n\3\n\5\n\u0171\n\n\3\n\5\n\u0174")
        buf.write("\n\n\3\n\3\n\3\n\3\n\5\n\u017a\n\n\3\n\5\n\u017d\n\n\3")
        buf.write("\n\3\n\5\n\u0181\n\n\3\n\5\n\u0184\n\n\3\n\3\n\3\n\5\n")
        buf.write("\u0189\n\n\5\n\u018b\n\n\3\n\3\n\3\n\5\n\u0190\n\n\3\13")
        buf.write("\5\13\u0193\n\13\3\13\3\13\3\13\5\13\u0198\n\13\3\13\5")
        buf.write("\13\u019b\n\13\3\f\3\f\3\f\5\f\u01a0\n\f\3\f\3\f\5\f\u01a4")
        buf.write("\n\f\3\r\3\r\5\r\u01a8\n\r\3\r\5\r\u01ab\n\r\6\r\u01ad")
        buf.write("\n\r\r\r\16\r\u01ae\3\r\3\r\5\r\u01b3\n\r\3\r\5\r\u01b6")
        buf.write("\n\r\3\r\3\r\5\r\u01ba\n\r\3\r\3\r\3\r\3\r\5\r\u01c0\n")
        buf.write("\r\3\r\3\r\5\r\u01c4\n\r\5\r\u01c6\n\r\3\r\5\r\u01c9\n")
        buf.write("\r\6\r\u01cb\n\r\r\r\16\r\u01cc\3\16\3\16\5\16\u01d1\n")
        buf.write("\16\3\16\5\16\u01d4\n\16\6\16\u01d6\n\16\r\16\16\16\u01d7")
        buf.write("\3\16\5\16\u01db\n\16\3\16\3\16\3\16\5\16\u01e0\n\16\3")
        buf.write("\16\3\16\5\16\u01e4\n\16\3\17\5\17\u01e7\n\17\3\17\3\17")
        buf.write("\5\17\u01eb\n\17\3\17\5\17\u01ee\n\17\3\17\5\17\u01f1")
        buf.write("\n\17\3\17\3\17\3\17\6\17\u01f6\n\17\r\17\16\17\u01f7")
        buf.write("\3\20\5\20\u01fb\n\20\3\20\3\20\5\20\u01ff\n\20\3\20\3")
        buf.write("\20\5\20\u0203\n\20\3\20\5\20\u0206\n\20\6\20\u0208\n")
        buf.write("\20\r\20\16\20\u0209\3\21\3\21\3\21\3\21\3\21\3\21\5\21")
        buf.write("\u0212\n\21\3\21\3\21\5\21\u0216\n\21\3\21\3\21\3\21\3")
        buf.write("\21\3\21\3\21\3\21\3\21\3\21\3\21\5\21\u0222\n\21\5\21")
        buf.write("\u0224\n\21\3\22\3\22\3\23\3\23\3\24\3\24\3\24\3\24\5")
        buf.write("\24\u022e\n\24\3\24\5\24\u0231\n\24\3\25\3\25\3\26\3\26")
        buf.write("\3\27\3\27\3\30\3\30\3\31\3\31\3\32\3\32\3\32\3\32\5\32")
        buf.write("\u0241\n\32\3\33\3\33\3\33\3\34\3\34\3\34\3\35\3\35\3")
        buf.write("\35\3\36\3\36\3\36\3\37\3\37\3 \3 \3 \3 \3 \3 \3 \3 \3")
        buf.write(" \5 \u025a\n \3!\3!\3!\3\"\3\"\3\"\3\"\3#\3#\3#\3#\5#")
        buf.write("\u0267\n#\3$\3$\3$\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3")
        buf.write("%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3")
        buf.write("%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3%\3")
        buf.write("%\3%\3%\3%\5%\u029f\n%\3&\3&\3&\3&\5&\u02a5\n&\3&\5&\u02a8")
        buf.write("\n&\3\'\3\'\3\'\5\'\u02ad\n\'\3(\3(\3(\3(\2\2)\2\4\6\b")
        buf.write("\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668")
        buf.write(":<>@BDFHJLN\2\20\3\2\6\7\3\2\b\t\4\2\b\b\n\13\4\2\7\7")
        buf.write("\f\17\4\2\f\f\22\22\4\2\13\13\r\16\3\2\26\27\3\2\r\16")
        buf.write("\4\2\5\5\r\r\3\2\30\36\3\2 #\3\2\13\r\4\2\4\4$$\3\2)*")
        buf.write("\2\u0336\2j\3\2\2\2\4\u00a9\3\2\2\2\6\u00fd\3\2\2\2\b")
        buf.write("\u00ff\3\2\2\2\n\u011c\3\2\2\2\f\u011e\3\2\2\2\16\u012e")
        buf.write("\3\2\2\2\20\u0130\3\2\2\2\22\u018f\3\2\2\2\24\u0192\3")
        buf.write("\2\2\2\26\u019f\3\2\2\2\30\u01b2\3\2\2\2\32\u01d5\3\2")
        buf.write("\2\2\34\u01e6\3\2\2\2\36\u01fa\3\2\2\2 \u0223\3\2\2\2")
        buf.write("\"\u0225\3\2\2\2$\u0227\3\2\2\2&\u0229\3\2\2\2(\u0232")
        buf.write("\3\2\2\2*\u0234\3\2\2\2,\u0236\3\2\2\2.\u0238\3\2\2\2")
        buf.write("\60\u023a\3\2\2\2\62\u0240\3\2\2\2\64\u0242\3\2\2\2\66")
        buf.write("\u0245\3\2\2\28\u0248\3\2\2\2:\u024b\3\2\2\2<\u024e\3")
        buf.write("\2\2\2>\u0259\3\2\2\2@\u025b\3\2\2\2B\u025e\3\2\2\2D\u0266")
        buf.write("\3\2\2\2F\u0268\3\2\2\2H\u029e\3\2\2\2J\u02a7\3\2\2\2")
        buf.write("L\u02ac\3\2\2\2N\u02ae\3\2\2\2P^\7D\2\2QT\7H\2\2RU\5*")
        buf.write("\26\2SU\5.\30\2TR\3\2\2\2TS\3\2\2\2TU\3\2\2\2UV\3\2\2")
        buf.write("\2V_\5\6\4\2WY\5\6\4\2XZ\7H\2\2YX\3\2\2\2YZ\3\2\2\2Z\\")
        buf.write("\3\2\2\2[]\5\4\3\2\\[\3\2\2\2\\]\3\2\2\2]_\3\2\2\2^Q\3")
        buf.write("\2\2\2^W\3\2\2\2_k\3\2\2\2`b\5\6\4\2ac\7\3\2\2ba\3\2\2")
        buf.write("\2bc\3\2\2\2ce\3\2\2\2df\7H\2\2ed\3\2\2\2ef\3\2\2\2fh")
        buf.write("\3\2\2\2gi\5\4\3\2hg\3\2\2\2hi\3\2\2\2ik\3\2\2\2jP\3\2")
        buf.write("\2\2j`\3\2\2\2ks\3\2\2\2lo\5\22\n\2mp\7\4\2\2np\5\4\3")
        buf.write("\2om\3\2\2\2on\3\2\2\2op\3\2\2\2pr\3\2\2\2ql\3\2\2\2r")
        buf.write("u\3\2\2\2sq\3\2\2\2st\3\2\2\2tw\3\2\2\2us\3\2\2\2vx\5")
        buf.write("\b\5\2wv\3\2\2\2wx\3\2\2\2x\u0084\3\2\2\2y\177\7\5\2\2")
        buf.write("z|\7\3\2\2{}\7H\2\2|{\3\2\2\2|}\3\2\2\2}\177\3\2\2\2~")
        buf.write("y\3\2\2\2~z\3\2\2\2~\177\3\2\2\2\177\u0081\3\2\2\2\u0080")
        buf.write("\u0082\5\4\3\2\u0081\u0080\3\2\2\2\u0081\u0082\3\2\2\2")
        buf.write("\u0082\u0083\3\2\2\2\u0083\u0085\5 \21\2\u0084~\3\2\2")
        buf.write("\2\u0084\u0085\3\2\2\2\u0085\u0088\3\2\2\2\u0086\u0087")
        buf.write("\t\2\2\2\u0087\u0089\5J&\2\u0088\u0086\3\2\2\2\u0088\u0089")
        buf.write("\3\2\2\2\u0089\u008b\3\2\2\2\u008a\u008c\5\22\n\2\u008b")
        buf.write("\u008a\3\2\2\2\u008b\u008c\3\2\2\2\u008c\u009a\3\2\2\2")
        buf.write("\u008d\u008f\t\3\2\2\u008e\u008d\3\2\2\2\u008e\u008f\3")
        buf.write("\2\2\2\u008f\u0094\3\2\2\2\u0090\u0092\5L\'\2\u0091\u0093")
        buf.write("\7\4\2\2\u0092\u0091\3\2\2\2\u0092\u0093\3\2\2\2\u0093")
        buf.write("\u0095\3\2\2\2\u0094\u0090\3\2\2\2\u0095\u0096\3\2\2\2")
        buf.write("\u0096\u0094\3\2\2\2\u0096\u0097\3\2\2\2\u0097\u0099\3")
        buf.write("\2\2\2\u0098\u008e\3\2\2\2\u0099\u009c\3\2\2\2\u009a\u0098")
        buf.write("\3\2\2\2\u009a\u009b\3\2\2\2\u009b\u00a7\3\2\2\2\u009c")
        buf.write("\u009a\3\2\2\2\u009d\u009f\t\4\2\2\u009e\u009d\3\2\2\2")
        buf.write("\u009e\u009f\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0\u00a2\5")
        buf.write("N(\2\u00a1\u00a3\7\f\2\2\u00a2\u00a1\3\2\2\2\u00a2\u00a3")
        buf.write("\3\2\2\2\u00a3\u00a5\3\2\2\2\u00a4\u00a6\5N(\2\u00a5\u00a4")
        buf.write("\3\2\2\2\u00a5\u00a6\3\2\2\2\u00a6\u00a8\3\2\2\2\u00a7")
        buf.write("\u009e\3\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\3\3\2\2\2\u00a9")
        buf.write("\u00aa\7I\2\2\u00aa\5\3\2\2\2\u00ab\u00fe\5\n\6\2\u00ac")
        buf.write("\u00ad\5\f\7\2\u00ad\u00ae\5H%\2\u00ae\u00fe\3\2\2\2\u00af")
        buf.write("\u00b1\5\"\22\2\u00b0\u00af\3\2\2\2\u00b0\u00b1\3\2\2")
        buf.write("\2\u00b1\u00b3\3\2\2\2\u00b2\u00b4\7R\2\2\u00b3\u00b2")
        buf.write("\3\2\2\2\u00b3\u00b4\3\2\2\2\u00b4\u00b9\3\2\2\2\u00b5")
        buf.write("\u00b7\5H%\2\u00b6\u00b8\7\4\2\2\u00b7\u00b6\3\2\2\2\u00b7")
        buf.write("\u00b8\3\2\2\2\u00b8\u00ba\3\2\2\2\u00b9\u00b5\3\2\2\2")
        buf.write("\u00ba\u00bb\3\2\2\2\u00bb\u00b9\3\2\2\2\u00bb\u00bc\3")
        buf.write("\2\2\2\u00bc\u00cd\3\2\2\2\u00bd\u00bf\t\5\2\2\u00be\u00c0")
        buf.write("\7R\2\2\u00bf\u00be\3\2\2\2\u00bf\u00c0\3\2\2\2\u00c0")
        buf.write("\u00c2\3\2\2\2\u00c1\u00c3\7\20\2\2\u00c2\u00c1\3\2\2")
        buf.write("\2\u00c2\u00c3\3\2\2\2\u00c3\u00c5\3\2\2\2\u00c4\u00c6")
        buf.write("\7\21\2\2\u00c5\u00c4\3\2\2\2\u00c5\u00c6\3\2\2\2\u00c6")
        buf.write("\u00c9\3\2\2\2\u00c7\u00ca\5H%\2\u00c8\u00ca\5<\37\2\u00c9")
        buf.write("\u00c7\3\2\2\2\u00c9\u00c8\3\2\2\2\u00ca\u00cc\3\2\2\2")
        buf.write("\u00cb\u00bd\3\2\2\2\u00cc\u00cf\3\2\2\2\u00cd\u00cb\3")
        buf.write("\2\2\2\u00cd\u00ce\3\2\2\2\u00ce\u00d1\3\2\2\2\u00cf\u00cd")
        buf.write("\3\2\2\2\u00d0\u00d2\5\16\b\2\u00d1\u00d0\3\2\2\2\u00d1")
        buf.write("\u00d2\3\2\2\2\u00d2\u00fe\3\2\2\2\u00d3\u00d5\5\"\22")
        buf.write("\2\u00d4\u00d3\3\2\2\2\u00d4\u00d5\3\2\2\2\u00d5\u00d9")
        buf.write("\3\2\2\2\u00d6\u00da\5@!\2\u00d7\u00da\5B\"\2\u00d8\u00da")
        buf.write("\5H%\2\u00d9\u00d6\3\2\2\2\u00d9\u00d7\3\2\2\2\u00d9\u00d8")
        buf.write("\3\2\2\2\u00da\u00e1\3\2\2\2\u00db\u00dd\t\6\2\2\u00dc")
        buf.write("\u00db\3\2\2\2\u00dc\u00dd\3\2\2\2\u00dd\u00de\3\2\2\2")
        buf.write("\u00de\u00e0\5\36\20\2\u00df\u00dc\3\2\2\2\u00e0\u00e3")
        buf.write("\3\2\2\2\u00e1\u00df\3\2\2\2\u00e1\u00e2\3\2\2\2\u00e2")
        buf.write("\u00ed\3\2\2\2\u00e3\u00e1\3\2\2\2\u00e4\u00e6\t\7\2\2")
        buf.write("\u00e5\u00e4\3\2\2\2\u00e5\u00e6\3\2\2\2\u00e6\u00e8\3")
        buf.write("\2\2\2\u00e7\u00e9\7\20\2\2\u00e8\u00e7\3\2\2\2\u00e8")
        buf.write("\u00e9\3\2\2\2\u00e9\u00ea\3\2\2\2\u00ea\u00ec\5\34\17")
        buf.write("\2\u00eb\u00e5\3\2\2\2\u00ec\u00ef\3\2\2\2\u00ed\u00eb")
        buf.write("\3\2\2\2\u00ed\u00ee\3\2\2\2\u00ee\u00f6\3\2\2\2\u00ef")
        buf.write("\u00ed\3\2\2\2\u00f0\u00f2\7\f\2\2\u00f1\u00f0\3\2\2\2")
        buf.write("\u00f1\u00f2\3\2\2\2\u00f2\u00f3\3\2\2\2\u00f3\u00f5\5")
        buf.write("\36\20\2\u00f4\u00f1\3\2\2\2\u00f5\u00f8\3\2\2\2\u00f6")
        buf.write("\u00f4\3\2\2\2\u00f6\u00f7\3\2\2\2\u00f7\u00fe\3\2\2\2")
        buf.write("\u00f8\u00f6\3\2\2\2\u00f9\u00fa\5H%\2\u00fa\u00fb\7\23")
        buf.write("\2\2\u00fb\u00fc\5@!\2\u00fc\u00fe\3\2\2\2\u00fd\u00ab")
        buf.write("\3\2\2\2\u00fd\u00ac\3\2\2\2\u00fd\u00b0\3\2\2\2\u00fd")
        buf.write("\u00d4\3\2\2\2\u00fd\u00f9\3\2\2\2\u00fe\7\3\2\2\2\u00ff")
        buf.write("\u0100\7\f\2\2\u0100\u0101\5H%\2\u0101\t\3\2\2\2\u0102")
        buf.write("\u0104\7E\2\2\u0103\u0105\7H\2\2\u0104\u0103\3\2\2\2\u0104")
        buf.write("\u0105\3\2\2\2\u0105\u0107\3\2\2\2\u0106\u0108\5\4\3\2")
        buf.write("\u0107\u0106\3\2\2\2\u0107\u0108\3\2\2\2\u0108\u0119\3")
        buf.write("\2\2\2\u0109\u011a\5\20\t\2\u010a\u010c\5*\26\2\u010b")
        buf.write("\u010a\3\2\2\2\u010b\u010c\3\2\2\2\u010c\u0111\3\2\2\2")
        buf.write("\u010d\u010f\5H%\2\u010e\u0110\7\4\2\2\u010f\u010e\3\2")
        buf.write("\2\2\u010f\u0110\3\2\2\2\u0110\u0112\3\2\2\2\u0111\u010d")
        buf.write("\3\2\2\2\u0112\u0113\3\2\2\2\u0113\u0111\3\2\2\2\u0113")
        buf.write("\u0114\3\2\2\2\u0114\u0117\3\2\2\2\u0115\u0116\7\r\2\2")
        buf.write("\u0116\u0118\5H%\2\u0117\u0115\3\2\2\2\u0117\u0118\3\2")
        buf.write("\2\2\u0118\u011a\3\2\2\2\u0119\u0109\3\2\2\2\u0119\u010b")
        buf.write("\3\2\2\2\u011a\u011d\3\2\2\2\u011b\u011d\7F\2\2\u011c")
        buf.write("\u0102\3\2\2\2\u011c\u011b\3\2\2\2\u011d\13\3\2\2\2\u011e")
        buf.write("\u011f\7G\2\2\u011f\r\3\2\2\2\u0120\u0122\7\24\2\2\u0121")
        buf.write("\u0123\5\"\22\2\u0122\u0121\3\2\2\2\u0122\u0123\3\2\2")
        buf.write("\2\u0123\u0124\3\2\2\2\u0124\u0127\5H%\2\u0125\u0126\7")
        buf.write("\r\2\2\u0126\u0128\5H%\2\u0127\u0125\3\2\2\2\u0127\u0128")
        buf.write("\3\2\2\2\u0128\u012f\3\2\2\2\u0129\u012b\7\25\2\2\u012a")
        buf.write("\u012c\5\"\22\2\u012b\u012a\3\2\2\2\u012b\u012c\3\2\2")
        buf.write("\2\u012c\u012d\3\2\2\2\u012d\u012f\5H%\2\u012e\u0120\3")
        buf.write("\2\2\2\u012e\u0129\3\2\2\2\u012f\17\3\2\2\2\u0130\u0131")
        buf.write("\t\b\2\2\u0131\u0133\t\t\2\2\u0132\u0134\7\21\2\2\u0133")
        buf.write("\u0132\3\2\2\2\u0133\u0134\3\2\2\2\u0134\u0135\3\2\2\2")
        buf.write("\u0135\u0136\5H%\2\u0136\21\3\2\2\2\u0137\u0190\5\26\f")
        buf.write("\2\u0138\u0148\5$\23\2\u0139\u0149\5\24\13\2\u013a\u0145")
        buf.write("\5H%\2\u013b\u0143\7\r\2\2\u013c\u013d\5H%\2\u013d\u013e")
        buf.write("\7\13\2\2\u013e\u013f\5\34\17\2\u013f\u0140\7\f\2\2\u0140")
        buf.write("\u0141\5\36\20\2\u0141\u0144\3\2\2\2\u0142\u0144\5H%\2")
        buf.write("\u0143\u013c\3\2\2\2\u0143\u0142\3\2\2\2\u0144\u0146\3")
        buf.write("\2\2\2\u0145\u013b\3\2\2\2\u0145\u0146\3\2\2\2\u0146\u0149")
        buf.write("\3\2\2\2\u0147\u0149\5:\36\2\u0148\u0139\3\2\2\2\u0148")
        buf.write("\u013a\3\2\2\2\u0148\u0147\3\2\2\2\u0149\u0190\3\2\2\2")
        buf.write("\u014a\u014c\7\5\2\2\u014b\u014a\3\2\2\2\u014b\u014c\3")
        buf.write("\2\2\2\u014c\u014d\3\2\2\2\u014d\u014f\5(\25\2\u014e\u0150")
        buf.write("\7\13\2\2\u014f\u014e\3\2\2\2\u014f\u0150\3\2\2\2\u0150")
        buf.write("\u0152\3\2\2\2\u0151\u0153\7R\2\2\u0152\u0151\3\2\2\2")
        buf.write("\u0152\u0153\3\2\2\2\u0153\u0156\3\2\2\2\u0154\u0157\5")
        buf.write("*\26\2\u0155\u0157\5\"\22\2\u0156\u0154\3\2\2\2\u0156")
        buf.write("\u0155\3\2\2\2\u0156\u0157\3\2\2\2\u0157\u0159\3\2\2\2")
        buf.write("\u0158\u015a\5H%\2\u0159\u0158\3\2\2\2\u0159\u015a\3\2")
        buf.write("\2\2\u015a\u0170\3\2\2\2\u015b\u015c\7\r\2\2\u015c\u015d")
        buf.write("\5H%\2\u015d\u015f\7\f\2\2\u015e\u0160\5H%\2\u015f\u015e")
        buf.write("\3\2\2\2\u0160\u0161\3\2\2\2\u0161\u015f\3\2\2\2\u0161")
        buf.write("\u0162\3\2\2\2\u0162\u0171\3\2\2\2\u0163\u0165\7\r\2\2")
        buf.write("\u0164\u0163\3\2\2\2\u0164\u0165\3\2\2\2\u0165\u0167\3")
        buf.write("\2\2\2\u0166\u0168\5\60\31\2\u0167\u0166\3\2\2\2\u0167")
        buf.write("\u0168\3\2\2\2\u0168\u016b\3\2\2\2\u0169\u016c\5\62\32")
        buf.write("\2\u016a\u016c\5H%\2\u016b\u0169\3\2\2\2\u016b\u016a\3")
        buf.write("\2\2\2\u016c\u0171\3\2\2\2\u016d\u0171\5\64\33\2\u016e")
        buf.write("\u0171\5\66\34\2\u016f\u0171\58\35\2\u0170\u015b\3\2\2")
        buf.write("\2\u0170\u0164\3\2\2\2\u0170\u016d\3\2\2\2\u0170\u016e")
        buf.write("\3\2\2\2\u0170\u016f\3\2\2\2\u0170\u0171\3\2\2\2\u0171")
        buf.write("\u0190\3\2\2\2\u0172\u0174\t\n\2\2\u0173\u0172\3\2\2\2")
        buf.write("\u0173\u0174\3\2\2\2\u0174\u0175\3\2\2\2\u0175\u017c\5")
        buf.write("\60\31\2\u0176\u017d\5\62\32\2\u0177\u017d\5\30\r\2\u0178")
        buf.write("\u017a\7R\2\2\u0179\u0178\3\2\2\2\u0179\u017a\3\2\2\2")
        buf.write("\u017a\u017b\3\2\2\2\u017b\u017d\5H%\2\u017c\u0176\3\2")
        buf.write("\2\2\u017c\u0177\3\2\2\2\u017c\u0179\3\2\2\2\u017d\u0190")
        buf.write("\3\2\2\2\u017e\u0181\5*\26\2\u017f\u0181\5,\27\2\u0180")
        buf.write("\u017e\3\2\2\2\u0180\u017f\3\2\2\2\u0181\u018a\3\2\2\2")
        buf.write("\u0182\u0184\7\20\2\2\u0183\u0182\3\2\2\2\u0183\u0184")
        buf.write("\3\2\2\2\u0184\u0185\3\2\2\2\u0185\u0188\5H%\2\u0186\u0187")
        buf.write("\7\r\2\2\u0187\u0189\5H%\2\u0188\u0186\3\2\2\2\u0188\u0189")
        buf.write("\3\2\2\2\u0189\u018b\3\2\2\2\u018a\u0183\3\2\2\2\u018a")
        buf.write("\u018b\3\2\2\2\u018b\u0190\3\2\2\2\u018c\u0190\5&\24\2")
        buf.write("\u018d\u0190\5H%\2\u018e\u0190\5\64\33\2\u018f\u0137\3")
        buf.write("\2\2\2\u018f\u0138\3\2\2\2\u018f\u014b\3\2\2\2\u018f\u0173")
        buf.write("\3\2\2\2\u018f\u0180\3\2\2\2\u018f\u018c\3\2\2\2\u018f")
        buf.write("\u018d\3\2\2\2\u018f\u018e\3\2\2\2\u0190\23\3\2\2\2\u0191")
        buf.write("\u0193\5\62\32\2\u0192\u0191\3\2\2\2\u0192\u0193\3\2\2")
        buf.write("\2\u0193\u0194\3\2\2\2\u0194\u019a\t\13\2\2\u0195\u0197")
        buf.write("\7\5\2\2\u0196\u0198\7\37\2\2\u0197\u0196\3\2\2\2\u0197")
        buf.write("\u0198\3\2\2\2\u0198\u0199\3\2\2\2\u0199\u019b\5\62\32")
        buf.write("\2\u019a\u0195\3\2\2\2\u019a\u019b\3\2\2\2\u019b\25\3")
        buf.write("\2\2\2\u019c\u01a0\5$\23\2\u019d\u01a0\5\60\31\2\u019e")
        buf.write("\u01a0\5*\26\2\u019f\u019c\3\2\2\2\u019f\u019d\3\2\2\2")
        buf.write("\u019f\u019e\3\2\2\2\u019f\u01a0\3\2\2\2\u01a0\u01a3\3")
        buf.write("\2\2\2\u01a1\u01a4\5\30\r\2\u01a2\u01a4\5\32\16\2\u01a3")
        buf.write("\u01a1\3\2\2\2\u01a3\u01a2\3\2\2\2\u01a4\27\3\2\2\2\u01a5")
        buf.write("\u01a7\5\62\32\2\u01a6\u01a8\7\4\2\2\u01a7\u01a6\3\2\2")
        buf.write("\2\u01a7\u01a8\3\2\2\2\u01a8\u01aa\3\2\2\2\u01a9\u01ab")
        buf.write("\t\f\2\2\u01aa\u01a9\3\2\2\2\u01aa\u01ab\3\2\2\2\u01ab")
        buf.write("\u01ad\3\2\2\2\u01ac\u01a5\3\2\2\2\u01ad\u01ae\3\2\2\2")
        buf.write("\u01ae\u01ac\3\2\2\2\u01ae\u01af\3\2\2\2\u01af\u01b3\3")
        buf.write("\2\2\2\u01b0\u01b3\7!\2\2\u01b1\u01b3\7#\2\2\u01b2\u01ac")
        buf.write("\3\2\2\2\u01b2\u01b0\3\2\2\2\u01b2\u01b1\3\2\2\2\u01b3")
        buf.write("\u01ca\3\2\2\2\u01b4\u01b6\t\r\2\2\u01b5\u01b4\3\2\2\2")
        buf.write("\u01b5\u01b6\3\2\2\2\u01b6\u01b9\3\2\2\2\u01b7\u01ba\5")
        buf.write("*\26\2\u01b8\u01ba\5.\30\2\u01b9\u01b7\3\2\2\2\u01b9\u01b8")
        buf.write("\3\2\2\2\u01b9\u01ba\3\2\2\2\u01ba\u01c5\3\2\2\2\u01bb")
        buf.write("\u01c6\5H%\2\u01bc\u01bf\5@!\2\u01bd\u01be\t\7\2\2\u01be")
        buf.write("\u01c0\5\34\17\2\u01bf\u01bd\3\2\2\2\u01bf\u01c0\3\2\2")
        buf.write("\2\u01c0\u01c3\3\2\2\2\u01c1\u01c2\7\f\2\2\u01c2\u01c4")
        buf.write("\5\36\20\2\u01c3\u01c1\3\2\2\2\u01c3\u01c4\3\2\2\2\u01c4")
        buf.write("\u01c6\3\2\2\2\u01c5\u01bb\3\2\2\2\u01c5\u01bc\3\2\2\2")
        buf.write("\u01c6\u01c8\3\2\2\2\u01c7\u01c9\t\16\2\2\u01c8\u01c7")
        buf.write("\3\2\2\2\u01c8\u01c9\3\2\2\2\u01c9\u01cb\3\2\2\2\u01ca")
        buf.write("\u01b5\3\2\2\2\u01cb\u01cc\3\2\2\2\u01cc\u01ca\3\2\2\2")
        buf.write("\u01cc\u01cd\3\2\2\2\u01cd\31\3\2\2\2\u01ce\u01d1\5\66")
        buf.write("\34\2\u01cf\u01d1\5\62\32\2\u01d0\u01ce\3\2\2\2\u01d0")
        buf.write("\u01cf\3\2\2\2\u01d1\u01d3\3\2\2\2\u01d2\u01d4\7\4\2\2")
        buf.write("\u01d3\u01d2\3\2\2\2\u01d3\u01d4\3\2\2\2\u01d4\u01d6\3")
        buf.write("\2\2\2\u01d5\u01d0\3\2\2\2\u01d6\u01d7\3\2\2\2\u01d7\u01d5")
        buf.write("\3\2\2\2\u01d7\u01d8\3\2\2\2\u01d8\u01da\3\2\2\2\u01d9")
        buf.write("\u01db\7\r\2\2\u01da\u01d9\3\2\2\2\u01da\u01db\3\2\2\2")
        buf.write("\u01db\u01dc\3\2\2\2\u01dc\u01df\5B\"\2\u01dd\u01de\t")
        buf.write("\7\2\2\u01de\u01e0\5\34\17\2\u01df\u01dd\3\2\2\2\u01df")
        buf.write("\u01e0\3\2\2\2\u01e0\u01e3\3\2\2\2\u01e1\u01e2\7\f\2\2")
        buf.write("\u01e2\u01e4\5\36\20\2\u01e3\u01e1\3\2\2\2\u01e3\u01e4")
        buf.write("\3\2\2\2\u01e4\33\3\2\2\2\u01e5\u01e7\7R\2\2\u01e6\u01e5")
        buf.write("\3\2\2\2\u01e6\u01e7\3\2\2\2\u01e7\u01ea\3\2\2\2\u01e8")
        buf.write("\u01eb\5*\26\2\u01e9\u01eb\5.\30\2\u01ea\u01e8\3\2\2\2")
        buf.write("\u01ea\u01e9\3\2\2\2\u01ea\u01eb\3\2\2\2\u01eb\u01ed\3")
        buf.write("\2\2\2\u01ec\u01ee\5D#\2\u01ed\u01ec\3\2\2\2\u01ed\u01ee")
        buf.write("\3\2\2\2\u01ee\u01f0\3\2\2\2\u01ef\u01f1\7\r\2\2\u01f0")
        buf.write("\u01ef\3\2\2\2\u01f0\u01f1\3\2\2\2\u01f1\u01f5\3\2\2\2")
        buf.write("\u01f2\u01f6\5D#\2\u01f3\u01f6\5F$\2\u01f4\u01f6\5\24")
        buf.write("\13\2\u01f5\u01f2\3\2\2\2\u01f5\u01f3\3\2\2\2\u01f5\u01f4")
        buf.write("\3\2\2\2\u01f6\u01f7\3\2\2\2\u01f7\u01f5\3\2\2\2\u01f7")
        buf.write("\u01f8\3\2\2\2\u01f8\35\3\2\2\2\u01f9\u01fb\7R\2\2\u01fa")
        buf.write("\u01f9\3\2\2\2\u01fa\u01fb\3\2\2\2\u01fb\u01fe\3\2\2\2")
        buf.write("\u01fc\u01ff\5*\26\2\u01fd\u01ff\5.\30\2\u01fe\u01fc\3")
        buf.write("\2\2\2\u01fe\u01fd\3\2\2\2\u01fe\u01ff\3\2\2\2\u01ff\u0207")
        buf.write("\3\2\2\2\u0200\u0203\5D#\2\u0201\u0203\5F$\2\u0202\u0200")
        buf.write("\3\2\2\2\u0202\u0201\3\2\2\2\u0203\u0205\3\2\2\2\u0204")
        buf.write("\u0206\7\4\2\2\u0205\u0204\3\2\2\2\u0205\u0206\3\2\2\2")
        buf.write("\u0206\u0208\3\2\2\2\u0207\u0202\3\2\2\2\u0208\u0209\3")
        buf.write("\2\2\2\u0209\u0207\3\2\2\2\u0209\u020a\3\2\2\2\u020a\37")
        buf.write("\3\2\2\2\u020b\u020c\5H%\2\u020c\u020d\5\60\31\2\u020d")
        buf.write("\u020e\5\62\32\2\u020e\u0224\3\2\2\2\u020f\u0212\5$\23")
        buf.write("\2\u0210\u0212\5*\26\2\u0211\u020f\3\2\2\2\u0211\u0210")
        buf.write("\3\2\2\2\u0212\u0215\3\2\2\2\u0213\u0216\5\30\r\2\u0214")
        buf.write("\u0216\5\32\16\2\u0215\u0213\3\2\2\2\u0215\u0214\3\2\2")
        buf.write("\2\u0216\u0224\3\2\2\2\u0217\u0218\5$\23\2\u0218\u0219")
        buf.write("\5H%\2\u0219\u0224\3\2\2\2\u021a\u021b\5\60\31\2\u021b")
        buf.write("\u021c\5H%\2\u021c\u0224\3\2\2\2\u021d\u021e\5,\27\2\u021e")
        buf.write("\u0221\5H%\2\u021f\u0220\7\r\2\2\u0220\u0222\5H%\2\u0221")
        buf.write("\u021f\3\2\2\2\u0221\u0222\3\2\2\2\u0222\u0224\3\2\2\2")
        buf.write("\u0223\u020b\3\2\2\2\u0223\u0211\3\2\2\2\u0223\u0217\3")
        buf.write("\2\2\2\u0223\u021a\3\2\2\2\u0223\u021d\3\2\2\2\u0224!")
        buf.write("\3\2\2\2\u0225\u0226\7J\2\2\u0226#\3\2\2\2\u0227\u0228")
        buf.write("\7K\2\2\u0228%\3\2\2\2\u0229\u0230\7\b\2\2\u022a\u022d")
        buf.write("\5H%\2\u022b\u022c\7\r\2\2\u022c\u022e\5H%\2\u022d\u022b")
        buf.write("\3\2\2\2\u022d\u022e\3\2\2\2\u022e\u0231\3\2\2\2\u022f")
        buf.write("\u0231\5:\36\2\u0230\u022a\3\2\2\2\u0230\u022f\3\2\2\2")
        buf.write("\u0231\'\3\2\2\2\u0232\u0233\7L\2\2\u0233)\3\2\2\2\u0234")
        buf.write("\u0235\7M\2\2\u0235+\3\2\2\2\u0236\u0237\7N\2\2\u0237")
        buf.write("-\3\2\2\2\u0238\u0239\7O\2\2\u0239/\3\2\2\2\u023a\u023b")
        buf.write("\7P\2\2\u023b\61\3\2\2\2\u023c\u023d\7%\2\2\u023d\u0241")
        buf.write("\7R\2\2\u023e\u023f\7&\2\2\u023f\u0241\7R\2\2\u0240\u023c")
        buf.write("\3\2\2\2\u0240\u023e\3\2\2\2\u0241\63\3\2\2\2\u0242\u0243")
        buf.write("\7\'\2\2\u0243\u0244\7R\2\2\u0244\65\3\2\2\2\u0245\u0246")
        buf.write("\7(\2\2\u0246\u0247\7R\2\2\u0247\67\3\2\2\2\u0248\u0249")
        buf.write("\7&\2\2\u0249\u024a\7R\2\2\u024a9\3\2\2\2\u024b\u024c")
        buf.write("\5\62\32\2\u024c\u024d\t\17\2\2\u024d;\3\2\2\2\u024e\u024f")
        buf.write("\7+\2\2\u024f=\3\2\2\2\u0250\u0251\5\62\32\2\u0251\u0252")
        buf.write("\7,\2\2\u0252\u025a\3\2\2\2\u0253\u0254\7,\2\2\u0254\u0255")
        buf.write("\5\62\32\2\u0255\u0256\7\23\2\2\u0256\u0257\5\62\32\2")
        buf.write("\u0257\u0258\7-\2\2\u0258\u025a\3\2\2\2\u0259\u0250\3")
        buf.write("\2\2\2\u0259\u0253\3\2\2\2\u025a?\3\2\2\2\u025b\u025c")
        buf.write("\7.\2\2\u025c\u025d\7R\2\2\u025dA\3\2\2\2\u025e\u025f")
        buf.write("\7/\2\2\u025f\u0260\7R\2\2\u0260\u0261\7Q\2\2\u0261C\3")
        buf.write("\2\2\2\u0262\u0263\7\60\2\2\u0263\u0267\7R\2\2\u0264\u0265")
        buf.write("\7\61\2\2\u0265\u0267\7R\2\2\u0266\u0262\3\2\2\2\u0266")
        buf.write("\u0264\3\2\2\2\u0267E\3\2\2\2\u0268\u0269\7\62\2\2\u0269")
        buf.write("\u026a\7R\2\2\u026aG\3\2\2\2\u026b\u026c\7\63\2\2\u026c")
        buf.write("\u026d\7R\2\2\u026d\u029f\7Q\2\2\u026e\u026f\7\60\2\2")
        buf.write("\u026f\u029f\7R\2\2\u0270\u0271\7\64\2\2\u0271\u0272\7")
        buf.write("R\2\2\u0272\u029f\7Q\2\2\u0273\u0274\7\62\2\2\u0274\u029f")
        buf.write("\7R\2\2\u0275\u0276\7\65\2\2\u0276\u0277\7R\2\2\u0277")
        buf.write("\u029f\7Q\2\2\u0278\u0279\7\66\2\2\u0279\u027a\7R\2\2")
        buf.write("\u027a\u029f\7Q\2\2\u027b\u027c\7\67\2\2\u027c\u027d\7")
        buf.write("R\2\2\u027d\u029f\7Q\2\2\u027e\u027f\78\2\2\u027f\u0280")
        buf.write("\7R\2\2\u0280\u029f\7Q\2\2\u0281\u0282\79\2\2\u0282\u0283")
        buf.write("\7R\2\2\u0283\u029f\7Q\2\2\u0284\u0285\7:\2\2\u0285\u029f")
        buf.write("\7R\2\2\u0286\u0287\7;\2\2\u0287\u0288\7R\2\2\u0288\u029f")
        buf.write("\7Q\2\2\u0289\u028a\7<\2\2\u028a\u028b\7R\2\2\u028b\u029f")
        buf.write("\7Q\2\2\u028c\u028d\7=\2\2\u028d\u028e\7R\2\2\u028e\u029f")
        buf.write("\7Q\2\2\u028f\u0290\7>\2\2\u0290\u0291\7R\2\2\u0291\u029f")
        buf.write("\7Q\2\2\u0292\u0293\7?\2\2\u0293\u0294\7R\2\2\u0294\u029f")
        buf.write("\7Q\2\2\u0295\u0296\7@\2\2\u0296\u0297\7R\2\2\u0297\u029f")
        buf.write("\7Q\2\2\u0298\u0299\7A\2\2\u0299\u029a\7R\2\2\u029a\u029f")
        buf.write("\7Q\2\2\u029b\u029c\7B\2\2\u029c\u029d\7R\2\2\u029d\u029f")
        buf.write("\7Q\2\2\u029e\u026b\3\2\2\2\u029e\u026e\3\2\2\2\u029e")
        buf.write("\u0270\3\2\2\2\u029e\u0273\3\2\2\2\u029e\u0275\3\2\2\2")
        buf.write("\u029e\u0278\3\2\2\2\u029e\u027b\3\2\2\2\u029e\u027e\3")
        buf.write("\2\2\2\u029e\u0281\3\2\2\2\u029e\u0284\3\2\2\2\u029e\u0286")
        buf.write("\3\2\2\2\u029e\u0289\3\2\2\2\u029e\u028c\3\2\2\2\u029e")
        buf.write("\u028f\3\2\2\2\u029e\u0292\3\2\2\2\u029e\u0295\3\2\2\2")
        buf.write("\u029e\u0298\3\2\2\2\u029e\u029b\3\2\2\2\u029fI\3\2\2")
        buf.write("\2\u02a0\u02a8\5\24\13\2\u02a1\u02a4\5H%\2\u02a2\u02a3")
        buf.write("\7\r\2\2\u02a3\u02a5\5H%\2\u02a4\u02a2\3\2\2\2\u02a4\u02a5")
        buf.write("\3\2\2\2\u02a5\u02a8\3\2\2\2\u02a6\u02a8\5> \2\u02a7\u02a0")
        buf.write("\3\2\2\2\u02a7\u02a1\3\2\2\2\u02a7\u02a6\3\2\2\2\u02a8")
        buf.write("K\3\2\2\2\u02a9\u02aa\7\61\2\2\u02aa\u02ad\7R\2\2\u02ab")
        buf.write("\u02ad\7C\2\2\u02ac\u02a9\3\2\2\2\u02ac\u02ab\3\2\2\2")
        buf.write("\u02adM\3\2\2\2\u02ae\u02af\7\'\2\2\u02af\u02b0\7R\2\2")
        buf.write("\u02b0O\3\2\2\2\177TY\\^behjosw|~\u0081\u0084\u0088\u008b")
        buf.write("\u008e\u0092\u0096\u009a\u009e\u00a2\u00a5\u00a7\u00b0")
        buf.write("\u00b3\u00b7\u00bb\u00bf\u00c2\u00c5\u00c9\u00cd\u00d1")
        buf.write("\u00d4\u00d9\u00dc\u00e1\u00e5\u00e8\u00ed\u00f1\u00f6")
        buf.write("\u00fd\u0104\u0107\u010b\u010f\u0113\u0117\u0119\u011c")
        buf.write("\u0122\u0127\u012b\u012e\u0133\u0143\u0145\u0148\u014b")
        buf.write("\u014f\u0152\u0156\u0159\u0161\u0164\u0167\u016b\u0170")
        buf.write("\u0173\u0179\u017c\u0180\u0183\u0188\u018a\u018f\u0192")
        buf.write("\u0197\u019a\u019f\u01a3\u01a7\u01aa\u01ae\u01b2\u01b5")
        buf.write("\u01b9\u01bf\u01c3\u01c5\u01c8\u01cc\u01d0\u01d3\u01d7")
        buf.write("\u01da\u01df\u01e3\u01e6\u01ea\u01ed\u01f0\u01f5\u01f7")
        buf.write("\u01fa\u01fe\u0202\u0205\u0209\u0211\u0215\u0221\u0223")
        buf.write("\u022d\u0230\u0240\u0259\u0266\u029e\u02a4\u02a7\u02ac")
        return buf.getvalue()


class GeoAnQuParser ( Parser ):

    grammarFileName = "GeoAnQu.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'that'", "'and'", "'with'", "'for each'", 
                     "'per'", "'in'", "'near'", "'on'", "'from'", "'to'", 
                     "'of'", "'for'", "'during'", "'each'", "'new'", "'through'", 
                     "'by'", "'weighted by'", "'with similar'", "'best site'", 
                     "'best sites'", "'grids'", "'grid cells'", "'grid'", 
                     "'grid cell'", "'hexagonal grids'", "'hexagonal grid'", 
                     "'hexagon grid'", "'diameter of'", "'area'", "'buffer area'", 
                     "'distance'", "'buffer areas'", "'or'", "'equantity'", 
                     "'epercent'", "'edate'", "'etime'", "'circle'", "'rectangle'", 
                     "'nearest neighbors'", "'distance band'", "'increments'", 
                     "'network'", "'networkquality'", "'object'", "'placename'", 
                     "'event'", "'field'", "'objectquality'", "'eventquality'", 
                     "'objconamount'", "'eveconamount'", "'conamount'", 
                     "'covamount'", "'amount'", "'objconobjconpro'", "'eveconobjconpro'", 
                     "'objconobjcovpro'", "'eveconobjcovpro'", "'conconpro'", 
                     "'concovpro'", "'covpro'", "'proportion'", "'world'", 
                     "<INVALID>", "'where'", "<INVALID>", "'how many'", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "','" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "WH", "Location1", "Location2", 
                      "ConAm", "AUX", "Flase", "Aggregate", "TOPO", "Boolean", 
                      "Extrema", "Distance", "ExtreDist", "Compare", "ML", 
                      "DIGIT", "WS", "COMMA" ]

    RULE_start = 0
    RULE_false = 1
    RULE_measure = 2
    RULE_measure1 = 3
    RULE_location = 4
    RULE_conAm = 5
    RULE_weight = 6
    RULE_allocation = 7
    RULE_condition = 8
    RULE_grid = 9
    RULE_boolField = 10
    RULE_distField = 11
    RULE_serviceObj = 12
    RULE_origin = 13
    RULE_destination = 14
    RULE_subcon = 15
    RULE_aggre = 16
    RULE_topoR = 17
    RULE_topoRIn = 18
    RULE_boolR = 19
    RULE_extremaR = 20
    RULE_distanceR = 21
    RULE_extreDist = 22
    RULE_compareR = 23
    RULE_quantity = 24
    RULE_date = 25
    RULE_time = 26
    RULE_percent = 27
    RULE_densityNei = 28
    RULE_distBandNei = 29
    RULE_distBand = 30
    RULE_networkC = 31
    RULE_networkQ = 32
    RULE_objectC = 33
    RULE_eventC = 34
    RULE_coreC = 35
    RULE_support = 36
    RULE_extent = 37
    RULE_temEx = 38

    ruleNames =  [ "start", "false", "measure", "measure1", "location", 
                   "conAm", "weight", "allocation", "condition", "grid", 
                   "boolField", "distField", "serviceObj", "origin", "destination", 
                   "subcon", "aggre", "topoR", "topoRIn", "boolR", "extremaR", 
                   "distanceR", "extreDist", "compareR", "quantity", "date", 
                   "time", "percent", "densityNei", "distBandNei", "distBand", 
                   "networkC", "networkQ", "objectC", "eventC", "coreC", 
                   "support", "extent", "temEx" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    WH=66
    Location1=67
    Location2=68
    ConAm=69
    AUX=70
    Flase=71
    Aggregate=72
    TOPO=73
    Boolean=74
    Extrema=75
    Distance=76
    ExtreDist=77
    Compare=78
    ML=79
    DIGIT=80
    WS=81
    COMMA=82

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class StartContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ConditionContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ConditionContext,i)


        def measure1(self):
            return self.getTypedRuleContext(GeoAnQuParser.Measure1Context,0)


        def subcon(self):
            return self.getTypedRuleContext(GeoAnQuParser.SubconContext,0)


        def support(self):
            return self.getTypedRuleContext(GeoAnQuParser.SupportContext,0)


        def temEx(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.TemExContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.TemExContext,i)


        def WH(self):
            return self.getToken(GeoAnQuParser.WH, 0)

        def measure(self):
            return self.getTypedRuleContext(GeoAnQuParser.MeasureContext,0)


        def false(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.FalseContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.FalseContext,i)


        def extent(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ExtentContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ExtentContext,i)


        def AUX(self, i:int=None):
            if i is None:
                return self.getTokens(GeoAnQuParser.AUX)
            else:
                return self.getToken(GeoAnQuParser.AUX, i)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def extreDist(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart" ):
                listener.enterStart(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart" ):
                listener.exitStart(self)




    def start(self):

        localctx = GeoAnQuParser.StartContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_start)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 104
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.WH]:
                self.state = 78
                self.match(GeoAnQuParser.WH)
                self.state = 92
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.AUX]:
                    self.state = 79
                    self.match(GeoAnQuParser.AUX)
                    self.state = 82
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.Extrema]:
                        self.state = 80
                        self.extremaR()
                        pass
                    elif token in [GeoAnQuParser.ExtreDist]:
                        self.state = 81
                        self.extreDist()
                        pass
                    elif token in [GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.Location1, GeoAnQuParser.Location2, GeoAnQuParser.ConAm, GeoAnQuParser.Aggregate, GeoAnQuParser.DIGIT]:
                        pass
                    else:
                        pass
                    self.state = 84
                    self.measure()
                    pass
                elif token in [GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.Location1, GeoAnQuParser.Location2, GeoAnQuParser.ConAm, GeoAnQuParser.Aggregate, GeoAnQuParser.DIGIT]:
                    self.state = 85
                    self.measure()
                    self.state = 87
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.AUX:
                        self.state = 86
                        self.match(GeoAnQuParser.AUX)


                    self.state = 90
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                    if la_ == 1:
                        self.state = 89
                        self.false()


                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [GeoAnQuParser.T__43, GeoAnQuParser.T__44, GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.Location1, GeoAnQuParser.Location2, GeoAnQuParser.ConAm, GeoAnQuParser.Aggregate, GeoAnQuParser.DIGIT]:
                self.state = 94
                self.measure()
                self.state = 96
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                if la_ == 1:
                    self.state = 95
                    self.match(GeoAnQuParser.T__0)


                self.state = 99
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.AUX:
                    self.state = 98
                    self.match(GeoAnQuParser.AUX)


                self.state = 102
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                if la_ == 1:
                    self.state = 101
                    self.false()


                pass
            else:
                raise NoViableAltException(self)

            self.state = 113
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 106
                    self.condition()
                    self.state = 109
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
                    if la_ == 1:
                        self.state = 107
                        self.match(GeoAnQuParser.T__1)

                    elif la_ == 2:
                        self.state = 108
                        self.false()

             
                self.state = 115
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__9:
                self.state = 116
                self.measure1()


            self.state = 130
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 124
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__2]:
                    self.state = 119
                    self.match(GeoAnQuParser.T__2)
                    pass
                elif token in [GeoAnQuParser.T__0]:
                    self.state = 120
                    self.match(GeoAnQuParser.T__0)
                    self.state = 122
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.AUX:
                        self.state = 121
                        self.match(GeoAnQuParser.AUX)


                    pass
                elif token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.Flase, GeoAnQuParser.TOPO, GeoAnQuParser.Extrema, GeoAnQuParser.Distance, GeoAnQuParser.Compare]:
                    pass
                else:
                    pass
                self.state = 127
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Flase:
                    self.state = 126
                    self.false()


                self.state = 129
                self.subcon()


            self.state = 134
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__3 or _la==GeoAnQuParser.T__4:
                self.state = 132
                _la = self._input.LA(1)
                if not(_la==GeoAnQuParser.T__3 or _la==GeoAnQuParser.T__4):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 133
                self.support()


            self.state = 137
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
            if la_ == 1:
                self.state = 136
                self.condition()


            self.state = 152
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,20,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 140
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__5 or _la==GeoAnQuParser.T__6:
                        self.state = 139
                        _la = self._input.LA(1)
                        if not(_la==GeoAnQuParser.T__5 or _la==GeoAnQuParser.T__6):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 146 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 142
                            self.extent()
                            self.state = 144
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==GeoAnQuParser.T__1:
                                self.state = 143
                                self.match(GeoAnQuParser.T__1)



                        else:
                            raise NoViableAltException(self)
                        self.state = 148 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,19,self._ctx)
             
                self.state = 154
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,20,self._ctx)

            self.state = 165
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__5) | (1 << GeoAnQuParser.T__7) | (1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__36))) != 0):
                self.state = 156
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__5) | (1 << GeoAnQuParser.T__7) | (1 << GeoAnQuParser.T__8))) != 0):
                    self.state = 155
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__5) | (1 << GeoAnQuParser.T__7) | (1 << GeoAnQuParser.T__8))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 158
                self.temEx()
                self.state = 160
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__9:
                    self.state = 159
                    self.match(GeoAnQuParser.T__9)


                self.state = 163
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__36:
                    self.state = 162
                    self.temEx()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FalseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Flase(self):
            return self.getToken(GeoAnQuParser.Flase, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_false

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFalse" ):
                listener.enterFalse(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFalse" ):
                listener.exitFalse(self)




    def false(self):

        localctx = GeoAnQuParser.FalseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_false)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 167
            self.match(GeoAnQuParser.Flase)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MeasureContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def location(self):
            return self.getTypedRuleContext(GeoAnQuParser.LocationContext,0)


        def conAm(self):
            return self.getTypedRuleContext(GeoAnQuParser.ConAmContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def aggre(self):
            return self.getTypedRuleContext(GeoAnQuParser.AggreContext,0)


        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(GeoAnQuParser.DIGIT)
            else:
                return self.getToken(GeoAnQuParser.DIGIT, i)

        def weight(self):
            return self.getTypedRuleContext(GeoAnQuParser.WeightContext,0)


        def distBandNei(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.DistBandNeiContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.DistBandNeiContext,i)


        def networkC(self):
            return self.getTypedRuleContext(GeoAnQuParser.NetworkCContext,0)


        def networkQ(self):
            return self.getTypedRuleContext(GeoAnQuParser.NetworkQContext,0)


        def destination(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.DestinationContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.DestinationContext,i)


        def origin(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.OriginContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.OriginContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_measure

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeasure" ):
                listener.enterMeasure(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeasure" ):
                listener.exitMeasure(self)




    def measure(self):

        localctx = GeoAnQuParser.MeasureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_measure)
        self._la = 0 # Token type
        try:
            self.state = 251
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 169
                self.location()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 170
                self.conAm()
                self.state = 171
                self.coreC()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 174
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 173
                    self.aggre()


                self.state = 177
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.DIGIT:
                    self.state = 176
                    self.match(GeoAnQuParser.DIGIT)


                self.state = 183 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 179
                        self.coreC()
                        self.state = 181
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__1:
                            self.state = 180
                            self.match(GeoAnQuParser.T__1)



                    else:
                        raise NoViableAltException(self)
                    self.state = 185 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

                self.state = 203
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,33,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 187
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__4) | (1 << GeoAnQuParser.T__9) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11) | (1 << GeoAnQuParser.T__12))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 189
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.DIGIT:
                            self.state = 188
                            self.match(GeoAnQuParser.DIGIT)


                        self.state = 192
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__13:
                            self.state = 191
                            self.match(GeoAnQuParser.T__13)


                        self.state = 195
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__14:
                            self.state = 194
                            self.match(GeoAnQuParser.T__14)


                        self.state = 199
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63]:
                            self.state = 197
                            self.coreC()
                            pass
                        elif token in [GeoAnQuParser.T__40]:
                            self.state = 198
                            self.distBandNei()
                            pass
                        else:
                            raise NoViableAltException(self)
                 
                    self.state = 205
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,33,self._ctx)

                self.state = 207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__17 or _la==GeoAnQuParser.T__18:
                    self.state = 206
                    self.weight()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 210
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 209
                    self.aggre()


                self.state = 215
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__43]:
                    self.state = 212
                    self.networkC()
                    pass
                elif token in [GeoAnQuParser.T__44]:
                    self.state = 213
                    self.networkQ()
                    pass
                elif token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63]:
                    self.state = 214
                    self.coreC()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 223
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,38,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 218
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__9 or _la==GeoAnQuParser.T__15:
                            self.state = 217
                            _la = self._input.LA(1)
                            if not(_la==GeoAnQuParser.T__9 or _la==GeoAnQuParser.T__15):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()


                        self.state = 220
                        self.destination() 
                    self.state = 225
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,38,self._ctx)

                self.state = 235
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,41,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 227
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
                        if la_ == 1:
                            self.state = 226
                            _la = self._input.LA(1)
                            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11))) != 0)):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()


                        self.state = 230
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__13:
                            self.state = 229
                            self.match(GeoAnQuParser.T__13)


                        self.state = 232
                        self.origin() 
                    self.state = 237
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

                self.state = 244
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,43,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 239
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GeoAnQuParser.T__9:
                            self.state = 238
                            self.match(GeoAnQuParser.T__9)


                        self.state = 241
                        self.destination() 
                    self.state = 246
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,43,self._ctx)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 247
                self.coreC()
                self.state = 248
                self.match(GeoAnQuParser.T__16)
                self.state = 249
                self.networkC()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Measure1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self):
            return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_measure1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeasure1" ):
                listener.enterMeasure1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeasure1" ):
                listener.exitMeasure1(self)




    def measure1(self):

        localctx = GeoAnQuParser.Measure1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_measure1)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 253
            self.match(GeoAnQuParser.T__9)
            self.state = 254
            self.coreC()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Location1(self):
            return self.getToken(GeoAnQuParser.Location1, 0)

        def allocation(self):
            return self.getTypedRuleContext(GeoAnQuParser.AllocationContext,0)


        def AUX(self):
            return self.getToken(GeoAnQuParser.AUX, 0)

        def false(self):
            return self.getTypedRuleContext(GeoAnQuParser.FalseContext,0)


        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def Location2(self):
            return self.getToken(GeoAnQuParser.Location2, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_location

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLocation" ):
                listener.enterLocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLocation" ):
                listener.exitLocation(self)




    def location(self):

        localctx = GeoAnQuParser.LocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_location)
        self._la = 0 # Token type
        try:
            self.state = 282
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.Location1]:
                self.enterOuterAlt(localctx, 1)
                self.state = 256
                self.match(GeoAnQuParser.Location1)
                self.state = 258
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.AUX:
                    self.state = 257
                    self.match(GeoAnQuParser.AUX)


                self.state = 261
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Flase:
                    self.state = 260
                    self.false()


                self.state = 279
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__19, GeoAnQuParser.T__20]:
                    self.state = 263
                    self.allocation()
                    pass
                elif token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63, GeoAnQuParser.Extrema]:
                    self.state = 265
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.Extrema:
                        self.state = 264
                        self.extremaR()


                    self.state = 271 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 267
                            self.coreC()
                            self.state = 269
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==GeoAnQuParser.T__1:
                                self.state = 268
                                self.match(GeoAnQuParser.T__1)



                        else:
                            raise NoViableAltException(self)
                        self.state = 273 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,49,self._ctx)

                    self.state = 277
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
                    if la_ == 1:
                        self.state = 275
                        self.match(GeoAnQuParser.T__10)
                        self.state = 276
                        self.coreC()


                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [GeoAnQuParser.Location2]:
                self.enterOuterAlt(localctx, 2)
                self.state = 281
                self.match(GeoAnQuParser.Location2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConAmContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ConAm(self):
            return self.getToken(GeoAnQuParser.ConAm, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_conAm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConAm" ):
                listener.enterConAm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConAm" ):
                listener.exitConAm(self)




    def conAm(self):

        localctx = GeoAnQuParser.ConAmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_conAm)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            self.match(GeoAnQuParser.ConAm)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WeightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def aggre(self):
            return self.getTypedRuleContext(GeoAnQuParser.AggreContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_weight

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeight" ):
                listener.enterWeight(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeight" ):
                listener.exitWeight(self)




    def weight(self):

        localctx = GeoAnQuParser.WeightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_weight)
        self._la = 0 # Token type
        try:
            self.state = 300
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__17]:
                self.enterOuterAlt(localctx, 1)
                self.state = 286
                self.match(GeoAnQuParser.T__17)
                self.state = 288
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 287
                    self.aggre()


                self.state = 290
                self.coreC()
                self.state = 293
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
                if la_ == 1:
                    self.state = 291
                    self.match(GeoAnQuParser.T__10)
                    self.state = 292
                    self.coreC()


                pass
            elif token in [GeoAnQuParser.T__18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 295
                self.match(GeoAnQuParser.T__18)
                self.state = 297
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.Aggregate:
                    self.state = 296
                    self.aggre()


                self.state = 299
                self.coreC()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AllocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self):
            return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_allocation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAllocation" ):
                listener.enterAllocation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAllocation" ):
                listener.exitAllocation(self)




    def allocation(self):

        localctx = GeoAnQuParser.AllocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_allocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            _la = self._input.LA(1)
            if not(_la==GeoAnQuParser.T__19 or _la==GeoAnQuParser.T__20):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 303
            _la = self._input.LA(1)
            if not(_la==GeoAnQuParser.T__10 or _la==GeoAnQuParser.T__11):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 305
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__14:
                self.state = 304
                self.match(GeoAnQuParser.T__14)


            self.state = 307
            self.coreC()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolField(self):
            return self.getTypedRuleContext(GeoAnQuParser.BoolFieldContext,0)


        def topoR(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRContext,0)


        def grid(self):
            return self.getTypedRuleContext(GeoAnQuParser.GridContext,0)


        def densityNei(self):
            return self.getTypedRuleContext(GeoAnQuParser.DensityNeiContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def origin(self):
            return self.getTypedRuleContext(GeoAnQuParser.OriginContext,0)


        def destination(self):
            return self.getTypedRuleContext(GeoAnQuParser.DestinationContext,0)


        def boolR(self):
            return self.getTypedRuleContext(GeoAnQuParser.BoolRContext,0)


        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def aggre(self):
            return self.getTypedRuleContext(GeoAnQuParser.AggreContext,0)


        def date(self):
            return self.getTypedRuleContext(GeoAnQuParser.DateContext,0)


        def time(self):
            return self.getTypedRuleContext(GeoAnQuParser.TimeContext,0)


        def percent(self):
            return self.getTypedRuleContext(GeoAnQuParser.PercentContext,0)


        def quantity(self):
            return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,0)


        def compareR(self):
            return self.getTypedRuleContext(GeoAnQuParser.CompareRContext,0)


        def distField(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistFieldContext,0)


        def distanceR(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistanceRContext,0)


        def topoRIn(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRInContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_condition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondition" ):
                listener.enterCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondition" ):
                listener.exitCondition(self)




    def condition(self):

        localctx = GeoAnQuParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_condition)
        self._la = 0 # Token type
        try:
            self.state = 397
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 309
                self.boolField()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 310
                self.topoR()
                self.state = 326
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,60,self._ctx)
                if la_ == 1:
                    self.state = 311
                    self.grid()
                    pass

                elif la_ == 2:
                    self.state = 312
                    self.coreC()
                    self.state = 323
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
                    if la_ == 1:
                        self.state = 313
                        self.match(GeoAnQuParser.T__10)
                        self.state = 321
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,58,self._ctx)
                        if la_ == 1:
                            self.state = 314
                            self.coreC()
                            self.state = 315
                            self.match(GeoAnQuParser.T__8)
                            self.state = 316
                            self.origin()
                            self.state = 317
                            self.match(GeoAnQuParser.T__9)
                            self.state = 318
                            self.destination()
                            pass

                        elif la_ == 2:
                            self.state = 320
                            self.coreC()
                            pass




                    pass

                elif la_ == 3:
                    self.state = 325
                    self.densityNei()
                    pass


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 329
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__2:
                    self.state = 328
                    self.match(GeoAnQuParser.T__2)


                self.state = 331
                self.boolR()
                self.state = 333
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
                if la_ == 1:
                    self.state = 332
                    self.match(GeoAnQuParser.T__8)


                self.state = 336
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.DIGIT:
                    self.state = 335
                    self.match(GeoAnQuParser.DIGIT)


                self.state = 340
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
                if la_ == 1:
                    self.state = 338
                    self.extremaR()

                elif la_ == 2:
                    self.state = 339
                    self.aggre()


                self.state = 343
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
                if la_ == 1:
                    self.state = 342
                    self.coreC()


                self.state = 366
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
                if la_ == 1:
                    self.state = 345
                    self.match(GeoAnQuParser.T__10)
                    self.state = 346
                    self.coreC()
                    self.state = 347
                    self.match(GeoAnQuParser.T__9)
                    self.state = 349 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 348
                            self.coreC()

                        else:
                            raise NoViableAltException(self)
                        self.state = 351 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,66,self._ctx)


                elif la_ == 2:
                    self.state = 354
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__10:
                        self.state = 353
                        self.match(GeoAnQuParser.T__10)


                    self.state = 357
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.Compare:
                        self.state = 356
                        self.compareR()


                    self.state = 361
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                        self.state = 359
                        self.quantity()
                        pass
                    elif token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63]:
                        self.state = 360
                        self.coreC()
                        pass
                    else:
                        raise NoViableAltException(self)


                elif la_ == 3:
                    self.state = 363
                    self.date()

                elif la_ == 4:
                    self.state = 364
                    self.time()

                elif la_ == 5:
                    self.state = 365
                    self.percent()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 369
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__2 or _la==GeoAnQuParser.T__10:
                    self.state = 368
                    _la = self._input.LA(1)
                    if not(_la==GeoAnQuParser.T__2 or _la==GeoAnQuParser.T__10):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 371
                self.compareR()
                self.state = 378
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,73,self._ctx)
                if la_ == 1:
                    self.state = 372
                    self.quantity()
                    pass

                elif la_ == 2:
                    self.state = 373
                    self.distField()
                    pass

                elif la_ == 3:
                    self.state = 375
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.DIGIT:
                        self.state = 374
                        self.match(GeoAnQuParser.DIGIT)


                    self.state = 377
                    self.coreC()
                    pass


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 382
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.Extrema]:
                    self.state = 380
                    self.extremaR()
                    pass
                elif token in [GeoAnQuParser.Distance]:
                    self.state = 381
                    self.distanceR()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 392
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                if la_ == 1:
                    self.state = 385
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__13:
                        self.state = 384
                        self.match(GeoAnQuParser.T__13)


                    self.state = 387
                    self.coreC()
                    self.state = 390
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
                    if la_ == 1:
                        self.state = 388
                        self.match(GeoAnQuParser.T__10)
                        self.state = 389
                        self.coreC()




                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 394
                self.topoRIn()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 395
                self.coreC()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 396
                self.date()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GridContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_grid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrid" ):
                listener.enterGrid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrid" ):
                listener.exitGrid(self)




    def grid(self):

        localctx = GeoAnQuParser.GridContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_grid)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 400
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__34 or _la==GeoAnQuParser.T__35:
                self.state = 399
                self.quantity()


            self.state = 402
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__21) | (1 << GeoAnQuParser.T__22) | (1 << GeoAnQuParser.T__23) | (1 << GeoAnQuParser.T__24) | (1 << GeoAnQuParser.T__25) | (1 << GeoAnQuParser.T__26) | (1 << GeoAnQuParser.T__27))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 408
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
            if la_ == 1:
                self.state = 403
                self.match(GeoAnQuParser.T__2)
                self.state = 405
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__28:
                    self.state = 404
                    self.match(GeoAnQuParser.T__28)


                self.state = 407
                self.quantity()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolFieldContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def distField(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistFieldContext,0)


        def serviceObj(self):
            return self.getTypedRuleContext(GeoAnQuParser.ServiceObjContext,0)


        def topoR(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRContext,0)


        def compareR(self):
            return self.getTypedRuleContext(GeoAnQuParser.CompareRContext,0)


        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_boolField

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolField" ):
                listener.enterBoolField(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolField" ):
                listener.exitBoolField(self)




    def boolField(self):

        localctx = GeoAnQuParser.BoolFieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_boolField)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 413
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.TOPO]:
                self.state = 410
                self.topoR()
                pass
            elif token in [GeoAnQuParser.Compare]:
                self.state = 411
                self.compareR()
                pass
            elif token in [GeoAnQuParser.Extrema]:
                self.state = 412
                self.extremaR()
                pass
            elif token in [GeoAnQuParser.T__30, GeoAnQuParser.T__32, GeoAnQuParser.T__34, GeoAnQuParser.T__35, GeoAnQuParser.T__37]:
                pass
            else:
                pass
            self.state = 417
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,83,self._ctx)
            if la_ == 1:
                self.state = 415
                self.distField()
                pass

            elif la_ == 2:
                self.state = 416
                self.serviceObj()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistFieldContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def extremaR(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ExtremaRContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,i)


        def extreDist(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ExtreDistContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,i)


        def networkC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.NetworkCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.NetworkCContext,i)


        def origin(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.OriginContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.OriginContext,i)


        def destination(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.DestinationContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.DestinationContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distField

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistField" ):
                listener.enterDistField(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistField" ):
                listener.exitDistField(self)




    def distField(self):

        localctx = GeoAnQuParser.DistFieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_distField)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 432
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                self.state = 426 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 419
                    self.quantity()
                    self.state = 421
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GeoAnQuParser.T__1:
                        self.state = 420
                        self.match(GeoAnQuParser.T__1)


                    self.state = 424
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__29) | (1 << GeoAnQuParser.T__30) | (1 << GeoAnQuParser.T__31) | (1 << GeoAnQuParser.T__32))) != 0):
                        self.state = 423
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__29) | (1 << GeoAnQuParser.T__30) | (1 << GeoAnQuParser.T__31) | (1 << GeoAnQuParser.T__32))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 428 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==GeoAnQuParser.T__34 or _la==GeoAnQuParser.T__35):
                        break

                pass
            elif token in [GeoAnQuParser.T__30]:
                self.state = 430
                self.match(GeoAnQuParser.T__30)
                pass
            elif token in [GeoAnQuParser.T__32]:
                self.state = 431
                self.match(GeoAnQuParser.T__32)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 456 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 435
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__9) | (1 << GeoAnQuParser.T__10))) != 0):
                        self.state = 434
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__9) | (1 << GeoAnQuParser.T__10))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    self.state = 439
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.Extrema]:
                        self.state = 437
                        self.extremaR()
                        pass
                    elif token in [GeoAnQuParser.ExtreDist]:
                        self.state = 438
                        self.extreDist()
                        pass
                    elif token in [GeoAnQuParser.T__43, GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63]:
                        pass
                    else:
                        pass
                    self.state = 451
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63]:
                        self.state = 441
                        self.coreC()
                        pass
                    elif token in [GeoAnQuParser.T__43]:
                        self.state = 442
                        self.networkC()
                        self.state = 445
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,90,self._ctx)
                        if la_ == 1:
                            self.state = 443
                            _la = self._input.LA(1)
                            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11))) != 0)):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()
                            self.state = 444
                            self.origin()


                        self.state = 449
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
                        if la_ == 1:
                            self.state = 447
                            self.match(GeoAnQuParser.T__9)
                            self.state = 448
                            self.destination()


                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 454
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
                    if la_ == 1:
                        self.state = 453
                        _la = self._input.LA(1)
                        if not(_la==GeoAnQuParser.T__1 or _la==GeoAnQuParser.T__33):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()



                else:
                    raise NoViableAltException(self)
                self.state = 458 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,94,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ServiceObjContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def networkQ(self):
            return self.getTypedRuleContext(GeoAnQuParser.NetworkQContext,0)


        def origin(self):
            return self.getTypedRuleContext(GeoAnQuParser.OriginContext,0)


        def destination(self):
            return self.getTypedRuleContext(GeoAnQuParser.DestinationContext,0)


        def time(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.TimeContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.TimeContext,i)


        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_serviceObj

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterServiceObj" ):
                listener.enterServiceObj(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitServiceObj" ):
                listener.exitServiceObj(self)




    def serviceObj(self):

        localctx = GeoAnQuParser.ServiceObjContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_serviceObj)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 467 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 462
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.T__37]:
                    self.state = 460
                    self.time()
                    pass
                elif token in [GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                    self.state = 461
                    self.quantity()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 465
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GeoAnQuParser.T__1:
                    self.state = 464
                    self.match(GeoAnQuParser.T__1)


                self.state = 469 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__34) | (1 << GeoAnQuParser.T__35) | (1 << GeoAnQuParser.T__37))) != 0)):
                    break

            self.state = 472
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__10:
                self.state = 471
                self.match(GeoAnQuParser.T__10)


            self.state = 474
            self.networkQ()
            self.state = 477
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 475
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GeoAnQuParser.T__8) | (1 << GeoAnQuParser.T__10) | (1 << GeoAnQuParser.T__11))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 476
                self.origin()


            self.state = 481
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.state = 479
                self.match(GeoAnQuParser.T__9)
                self.state = 480
                self.destination()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OriginContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def extreDist(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,0)


        def objectC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ObjectCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ObjectCContext,i)


        def eventC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.EventCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.EventCContext,i)


        def grid(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.GridContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.GridContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_origin

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrigin" ):
                listener.enterOrigin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrigin" ):
                listener.exitOrigin(self)




    def origin(self):

        localctx = GeoAnQuParser.OriginContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_origin)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 484
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.DIGIT:
                self.state = 483
                self.match(GeoAnQuParser.DIGIT)


            self.state = 488
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.Extrema]:
                self.state = 486
                self.extremaR()
                pass
            elif token in [GeoAnQuParser.ExtreDist]:
                self.state = 487
                self.extreDist()
                pass
            elif token in [GeoAnQuParser.T__10, GeoAnQuParser.T__21, GeoAnQuParser.T__22, GeoAnQuParser.T__23, GeoAnQuParser.T__24, GeoAnQuParser.T__25, GeoAnQuParser.T__26, GeoAnQuParser.T__27, GeoAnQuParser.T__34, GeoAnQuParser.T__35, GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47]:
                pass
            else:
                pass
            self.state = 491
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.state = 490
                self.objectC()


            self.state = 494
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.T__10:
                self.state = 493
                self.match(GeoAnQuParser.T__10)


            self.state = 499 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 499
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__45, GeoAnQuParser.T__46]:
                        self.state = 496
                        self.objectC()
                        pass
                    elif token in [GeoAnQuParser.T__47]:
                        self.state = 497
                        self.eventC()
                        pass
                    elif token in [GeoAnQuParser.T__21, GeoAnQuParser.T__22, GeoAnQuParser.T__23, GeoAnQuParser.T__24, GeoAnQuParser.T__25, GeoAnQuParser.T__26, GeoAnQuParser.T__27, GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                        self.state = 498
                        self.grid()
                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 501 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,106,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DestinationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def extreDist(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtreDistContext,0)


        def objectC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.ObjectCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.ObjectCContext,i)


        def eventC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.EventCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.EventCContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_destination

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDestination" ):
                listener.enterDestination(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDestination" ):
                listener.exitDestination(self)




    def destination(self):

        localctx = GeoAnQuParser.DestinationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_destination)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 504
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GeoAnQuParser.DIGIT:
                self.state = 503
                self.match(GeoAnQuParser.DIGIT)


            self.state = 508
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.Extrema]:
                self.state = 506
                self.extremaR()
                pass
            elif token in [GeoAnQuParser.ExtreDist]:
                self.state = 507
                self.extreDist()
                pass
            elif token in [GeoAnQuParser.T__45, GeoAnQuParser.T__46, GeoAnQuParser.T__47]:
                pass
            else:
                pass
            self.state = 517 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 512
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GeoAnQuParser.T__45, GeoAnQuParser.T__46]:
                        self.state = 510
                        self.objectC()
                        pass
                    elif token in [GeoAnQuParser.T__47]:
                        self.state = 511
                        self.eventC()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 515
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,110,self._ctx)
                    if la_ == 1:
                        self.state = 514
                        self.match(GeoAnQuParser.T__1)



                else:
                    raise NoViableAltException(self)
                self.state = 519 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,111,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubconContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def compareR(self):
            return self.getTypedRuleContext(GeoAnQuParser.CompareRContext,0)


        def quantity(self):
            return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,0)


        def topoR(self):
            return self.getTypedRuleContext(GeoAnQuParser.TopoRContext,0)


        def extremaR(self):
            return self.getTypedRuleContext(GeoAnQuParser.ExtremaRContext,0)


        def distField(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistFieldContext,0)


        def serviceObj(self):
            return self.getTypedRuleContext(GeoAnQuParser.ServiceObjContext,0)


        def distanceR(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistanceRContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_subcon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSubcon" ):
                listener.enterSubcon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSubcon" ):
                listener.exitSubcon(self)




    def subcon(self):

        localctx = GeoAnQuParser.SubconContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_subcon)
        try:
            self.state = 545
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 521
                self.coreC()
                self.state = 522
                self.compareR()
                self.state = 523
                self.quantity()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 527
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GeoAnQuParser.TOPO]:
                    self.state = 525
                    self.topoR()
                    pass
                elif token in [GeoAnQuParser.Extrema]:
                    self.state = 526
                    self.extremaR()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 531
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,113,self._ctx)
                if la_ == 1:
                    self.state = 529
                    self.distField()
                    pass

                elif la_ == 2:
                    self.state = 530
                    self.serviceObj()
                    pass


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 533
                self.topoR()
                self.state = 534
                self.coreC()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 536
                self.compareR()
                self.state = 537
                self.coreC()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 539
                self.distanceR()
                self.state = 540
                self.coreC()
                self.state = 543
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
                if la_ == 1:
                    self.state = 541
                    self.match(GeoAnQuParser.T__10)
                    self.state = 542
                    self.coreC()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggreContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Aggregate(self):
            return self.getToken(GeoAnQuParser.Aggregate, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_aggre

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggre" ):
                listener.enterAggre(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggre" ):
                listener.exitAggre(self)




    def aggre(self):

        localctx = GeoAnQuParser.AggreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_aggre)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 547
            self.match(GeoAnQuParser.Aggregate)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopoRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TOPO(self):
            return self.getToken(GeoAnQuParser.TOPO, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_topoR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopoR" ):
                listener.enterTopoR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopoR" ):
                listener.exitTopoR(self)




    def topoR(self):

        localctx = GeoAnQuParser.TopoRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_topoR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 549
            self.match(GeoAnQuParser.TOPO)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopoRInContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def densityNei(self):
            return self.getTypedRuleContext(GeoAnQuParser.DensityNeiContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_topoRIn

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTopoRIn" ):
                listener.enterTopoRIn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTopoRIn" ):
                listener.exitTopoRIn(self)




    def topoRIn(self):

        localctx = GeoAnQuParser.TopoRInContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_topoRIn)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 551
            self.match(GeoAnQuParser.T__5)
            self.state = 558
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__45, GeoAnQuParser.T__47, GeoAnQuParser.T__48, GeoAnQuParser.T__49, GeoAnQuParser.T__50, GeoAnQuParser.T__51, GeoAnQuParser.T__52, GeoAnQuParser.T__53, GeoAnQuParser.T__54, GeoAnQuParser.T__55, GeoAnQuParser.T__56, GeoAnQuParser.T__57, GeoAnQuParser.T__58, GeoAnQuParser.T__59, GeoAnQuParser.T__60, GeoAnQuParser.T__61, GeoAnQuParser.T__62, GeoAnQuParser.T__63]:
                self.state = 552
                self.coreC()
                self.state = 555
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
                if la_ == 1:
                    self.state = 553
                    self.match(GeoAnQuParser.T__10)
                    self.state = 554
                    self.coreC()


                pass
            elif token in [GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                self.state = 557
                self.densityNei()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Boolean(self):
            return self.getToken(GeoAnQuParser.Boolean, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_boolR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolR" ):
                listener.enterBoolR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolR" ):
                listener.exitBoolR(self)




    def boolR(self):

        localctx = GeoAnQuParser.BoolRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_boolR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 560
            self.match(GeoAnQuParser.Boolean)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtremaRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Extrema(self):
            return self.getToken(GeoAnQuParser.Extrema, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_extremaR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtremaR" ):
                listener.enterExtremaR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtremaR" ):
                listener.exitExtremaR(self)




    def extremaR(self):

        localctx = GeoAnQuParser.ExtremaRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_extremaR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 562
            self.match(GeoAnQuParser.Extrema)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistanceRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Distance(self):
            return self.getToken(GeoAnQuParser.Distance, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distanceR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistanceR" ):
                listener.enterDistanceR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistanceR" ):
                listener.exitDistanceR(self)




    def distanceR(self):

        localctx = GeoAnQuParser.DistanceRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_distanceR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 564
            self.match(GeoAnQuParser.Distance)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtreDistContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ExtreDist(self):
            return self.getToken(GeoAnQuParser.ExtreDist, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_extreDist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtreDist" ):
                listener.enterExtreDist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtreDist" ):
                listener.exitExtreDist(self)




    def extreDist(self):

        localctx = GeoAnQuParser.ExtreDistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_extreDist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 566
            self.match(GeoAnQuParser.ExtreDist)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CompareRContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Compare(self):
            return self.getToken(GeoAnQuParser.Compare, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_compareR

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompareR" ):
                listener.enterCompareR(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompareR" ):
                listener.exitCompareR(self)




    def compareR(self):

        localctx = GeoAnQuParser.CompareRContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_compareR)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 568
            self.match(GeoAnQuParser.Compare)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuantityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_quantity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantity" ):
                listener.enterQuantity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantity" ):
                listener.exitQuantity(self)




    def quantity(self):

        localctx = GeoAnQuParser.QuantityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_quantity)
        try:
            self.state = 574
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__34]:
                self.enterOuterAlt(localctx, 1)
                self.state = 570
                self.match(GeoAnQuParser.T__34)
                self.state = 571
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__35]:
                self.enterOuterAlt(localctx, 2)
                self.state = 572
                self.match(GeoAnQuParser.T__35)
                self.state = 573
                self.match(GeoAnQuParser.DIGIT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)




    def date(self):

        localctx = GeoAnQuParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 576
            self.match(GeoAnQuParser.T__36)
            self.state = 577
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_time

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime" ):
                listener.enterTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime" ):
                listener.exitTime(self)




    def time(self):

        localctx = GeoAnQuParser.TimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_time)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 579
            self.match(GeoAnQuParser.T__37)
            self.state = 580
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PercentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_percent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPercent" ):
                listener.enterPercent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPercent" ):
                listener.exitPercent(self)




    def percent(self):

        localctx = GeoAnQuParser.PercentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_percent)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 582
            self.match(GeoAnQuParser.T__35)
            self.state = 583
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DensityNeiContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self):
            return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_densityNei

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDensityNei" ):
                listener.enterDensityNei(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDensityNei" ):
                listener.exitDensityNei(self)




    def densityNei(self):

        localctx = GeoAnQuParser.DensityNeiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_densityNei)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 585
            self.quantity()
            self.state = 586
            _la = self._input.LA(1)
            if not(_la==GeoAnQuParser.T__38 or _la==GeoAnQuParser.T__39):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistBandNeiContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distBandNei

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistBandNei" ):
                listener.enterDistBandNei(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistBandNei" ):
                listener.exitDistBandNei(self)




    def distBandNei(self):

        localctx = GeoAnQuParser.DistBandNeiContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_distBandNei)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 588
            self.match(GeoAnQuParser.T__40)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DistBandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.QuantityContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.QuantityContext,i)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_distBand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistBand" ):
                listener.enterDistBand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistBand" ):
                listener.exitDistBand(self)




    def distBand(self):

        localctx = GeoAnQuParser.DistBandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_distBand)
        try:
            self.state = 599
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__34, GeoAnQuParser.T__35]:
                self.enterOuterAlt(localctx, 1)
                self.state = 590
                self.quantity()
                self.state = 591
                self.match(GeoAnQuParser.T__41)
                pass
            elif token in [GeoAnQuParser.T__41]:
                self.enterOuterAlt(localctx, 2)
                self.state = 593
                self.match(GeoAnQuParser.T__41)
                self.state = 594
                self.quantity()
                self.state = 595
                self.match(GeoAnQuParser.T__16)
                self.state = 596
                self.quantity()
                self.state = 597
                self.match(GeoAnQuParser.T__42)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NetworkCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_networkC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNetworkC" ):
                listener.enterNetworkC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNetworkC" ):
                listener.exitNetworkC(self)




    def networkC(self):

        localctx = GeoAnQuParser.NetworkCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_networkC)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 601
            self.match(GeoAnQuParser.T__43)
            self.state = 602
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NetworkQContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def ML(self):
            return self.getToken(GeoAnQuParser.ML, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_networkQ

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNetworkQ" ):
                listener.enterNetworkQ(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNetworkQ" ):
                listener.exitNetworkQ(self)




    def networkQ(self):

        localctx = GeoAnQuParser.NetworkQContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_networkQ)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 604
            self.match(GeoAnQuParser.T__44)
            self.state = 605
            self.match(GeoAnQuParser.DIGIT)
            self.state = 606
            self.match(GeoAnQuParser.ML)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ObjectCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_objectC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObjectC" ):
                listener.enterObjectC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObjectC" ):
                listener.exitObjectC(self)




    def objectC(self):

        localctx = GeoAnQuParser.ObjectCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_objectC)
        try:
            self.state = 612
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__45]:
                self.enterOuterAlt(localctx, 1)
                self.state = 608
                self.match(GeoAnQuParser.T__45)
                self.state = 609
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__46]:
                self.enterOuterAlt(localctx, 2)
                self.state = 610
                self.match(GeoAnQuParser.T__46)
                self.state = 611
                self.match(GeoAnQuParser.DIGIT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_eventC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventC" ):
                listener.enterEventC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventC" ):
                listener.exitEventC(self)




    def eventC(self):

        localctx = GeoAnQuParser.EventCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_eventC)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 614
            self.match(GeoAnQuParser.T__47)
            self.state = 615
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CoreCContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def ML(self):
            return self.getToken(GeoAnQuParser.ML, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_coreC

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoreC" ):
                listener.enterCoreC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoreC" ):
                listener.exitCoreC(self)




    def coreC(self):

        localctx = GeoAnQuParser.CoreCContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_coreC)
        try:
            self.state = 668
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__48]:
                self.enterOuterAlt(localctx, 1)
                self.state = 617
                self.match(GeoAnQuParser.T__48)
                self.state = 618
                self.match(GeoAnQuParser.DIGIT)
                self.state = 619
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__45]:
                self.enterOuterAlt(localctx, 2)
                self.state = 620
                self.match(GeoAnQuParser.T__45)
                self.state = 621
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__49]:
                self.enterOuterAlt(localctx, 3)
                self.state = 622
                self.match(GeoAnQuParser.T__49)
                self.state = 623
                self.match(GeoAnQuParser.DIGIT)
                self.state = 624
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__47]:
                self.enterOuterAlt(localctx, 4)
                self.state = 625
                self.match(GeoAnQuParser.T__47)
                self.state = 626
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__50]:
                self.enterOuterAlt(localctx, 5)
                self.state = 627
                self.match(GeoAnQuParser.T__50)
                self.state = 628
                self.match(GeoAnQuParser.DIGIT)
                self.state = 629
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__51]:
                self.enterOuterAlt(localctx, 6)
                self.state = 630
                self.match(GeoAnQuParser.T__51)
                self.state = 631
                self.match(GeoAnQuParser.DIGIT)
                self.state = 632
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__52]:
                self.enterOuterAlt(localctx, 7)
                self.state = 633
                self.match(GeoAnQuParser.T__52)
                self.state = 634
                self.match(GeoAnQuParser.DIGIT)
                self.state = 635
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__53]:
                self.enterOuterAlt(localctx, 8)
                self.state = 636
                self.match(GeoAnQuParser.T__53)
                self.state = 637
                self.match(GeoAnQuParser.DIGIT)
                self.state = 638
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__54]:
                self.enterOuterAlt(localctx, 9)
                self.state = 639
                self.match(GeoAnQuParser.T__54)
                self.state = 640
                self.match(GeoAnQuParser.DIGIT)
                self.state = 641
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__55]:
                self.enterOuterAlt(localctx, 10)
                self.state = 642
                self.match(GeoAnQuParser.T__55)
                self.state = 643
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__56]:
                self.enterOuterAlt(localctx, 11)
                self.state = 644
                self.match(GeoAnQuParser.T__56)
                self.state = 645
                self.match(GeoAnQuParser.DIGIT)
                self.state = 646
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__57]:
                self.enterOuterAlt(localctx, 12)
                self.state = 647
                self.match(GeoAnQuParser.T__57)
                self.state = 648
                self.match(GeoAnQuParser.DIGIT)
                self.state = 649
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__58]:
                self.enterOuterAlt(localctx, 13)
                self.state = 650
                self.match(GeoAnQuParser.T__58)
                self.state = 651
                self.match(GeoAnQuParser.DIGIT)
                self.state = 652
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__59]:
                self.enterOuterAlt(localctx, 14)
                self.state = 653
                self.match(GeoAnQuParser.T__59)
                self.state = 654
                self.match(GeoAnQuParser.DIGIT)
                self.state = 655
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__60]:
                self.enterOuterAlt(localctx, 15)
                self.state = 656
                self.match(GeoAnQuParser.T__60)
                self.state = 657
                self.match(GeoAnQuParser.DIGIT)
                self.state = 658
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__61]:
                self.enterOuterAlt(localctx, 16)
                self.state = 659
                self.match(GeoAnQuParser.T__61)
                self.state = 660
                self.match(GeoAnQuParser.DIGIT)
                self.state = 661
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__62]:
                self.enterOuterAlt(localctx, 17)
                self.state = 662
                self.match(GeoAnQuParser.T__62)
                self.state = 663
                self.match(GeoAnQuParser.DIGIT)
                self.state = 664
                self.match(GeoAnQuParser.ML)
                pass
            elif token in [GeoAnQuParser.T__63]:
                self.enterOuterAlt(localctx, 18)
                self.state = 665
                self.match(GeoAnQuParser.T__63)
                self.state = 666
                self.match(GeoAnQuParser.DIGIT)
                self.state = 667
                self.match(GeoAnQuParser.ML)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SupportContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def grid(self):
            return self.getTypedRuleContext(GeoAnQuParser.GridContext,0)


        def coreC(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GeoAnQuParser.CoreCContext)
            else:
                return self.getTypedRuleContext(GeoAnQuParser.CoreCContext,i)


        def distBand(self):
            return self.getTypedRuleContext(GeoAnQuParser.DistBandContext,0)


        def getRuleIndex(self):
            return GeoAnQuParser.RULE_support

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSupport" ):
                listener.enterSupport(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSupport" ):
                listener.exitSupport(self)




    def support(self):

        localctx = GeoAnQuParser.SupportContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_support)
        try:
            self.state = 677
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,123,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 670
                self.grid()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 671
                self.coreC()
                self.state = 674
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
                if la_ == 1:
                    self.state = 672
                    self.match(GeoAnQuParser.T__10)
                    self.state = 673
                    self.coreC()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 676
                self.distBand()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExtentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_extent

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtent" ):
                listener.enterExtent(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtent" ):
                listener.exitExtent(self)




    def extent(self):

        localctx = GeoAnQuParser.ExtentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_extent)
        try:
            self.state = 682
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GeoAnQuParser.T__46]:
                self.enterOuterAlt(localctx, 1)
                self.state = 679
                self.match(GeoAnQuParser.T__46)
                self.state = 680
                self.match(GeoAnQuParser.DIGIT)
                pass
            elif token in [GeoAnQuParser.T__64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 681
                self.match(GeoAnQuParser.T__64)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemExContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self):
            return self.getToken(GeoAnQuParser.DIGIT, 0)

        def getRuleIndex(self):
            return GeoAnQuParser.RULE_temEx

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemEx" ):
                listener.enterTemEx(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemEx" ):
                listener.exitTemEx(self)




    def temEx(self):

        localctx = GeoAnQuParser.TemExContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_temEx)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 684
            self.match(GeoAnQuParser.T__36)
            self.state = 685
            self.match(GeoAnQuParser.DIGIT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





